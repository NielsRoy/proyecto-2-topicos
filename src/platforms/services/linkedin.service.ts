import { Inject, Injectable, Logger } from '@nestjs/common';
import { SocialMediaPublisher } from '../common/social-media-publisher.interface';
import { PublishResult } from '../interfaces/publish-result.interface';
import { env } from '../../config/env.config';
import { AxiosError, AxiosRequestConfig } from 'axios';
import { HttpService } from '@nestjs/axios';
import { PublicationData } from '../interfaces/publication-data.interface';
import { STORAGE_SERVICE } from '../../config/injection-tokens';
import type { StorageService } from '../../storage/common/file-storage.interface';

@Injectable()
export class LinkedInService implements SocialMediaPublisher {
  readonly platformName = 'linkedin';
  private readonly logger = new Logger('LinkedInService');
  private readonly plogger = new Logger('LinkedIn');

  private readonly baseUrl = "https://api.linkedin.com/v2";
  private readonly profileId = env.LINKEDIN_PROFILE_ID;
  private readonly accessToken = env.LINKEDIN_PROFILE_ACCESS_TOKEN;
  
  private readonly config: AxiosRequestConfig = {
    headers: {
      'Authorization': `Bearer ${this.accessToken}`,
      'Content-Type': 'application/json',
      'X-Restli-Protocol-Version': '2.0.0'
    },
  };

  constructor(
    private readonly httpService: HttpService,
    
    @Inject(STORAGE_SERVICE)
    private readonly storageService: StorageService,
  ) {}

  async publish(data: PublicationData): Promise<PublishResult> {
    try {
      const { textContent, fileUrl } = data;
      this.logger.log('Iniciando publicación en LinkedIn...');
      if (fileUrl) {
        return await this.publishWithImage(textContent, fileUrl);
      }
      return await this.publishText(textContent);
    } catch (error) {
      const axiosError = error as AxiosError;
      this.logger.error(`Fallo general LinkedIn: ${axiosError.message}`);
      return { success: false, platform: this.platformName, error: axiosError.message };
    }
  }

  private async publishText(content: string): Promise<PublishResult> {
    const body = {
      author: `urn:li:person:${this.profileId}`,
      lifecycleState: "PUBLISHED",
      specificContent: {
        "com.linkedin.ugc.ShareContent": {
          shareCommentary: { text: content },
          shareMediaCategory: "NONE"
        }
      },
      visibility: { "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC" }
    };
    return this.sendPostRequest(body);
  }

  private async publishWithImage(message: string, filepath: string): Promise<PublishResult> {
    this.logger.log(`Preparando carga de imagen: ${filepath}`);

    // PASO 1: Registrar la carga de la imagen 
    const registerUrl = `${this.baseUrl}/assets?action=registerUpload`;
    const registerBody = {
      registerUploadRequest: {
        recipes: ["urn:li:digitalmediaRecipe:feedshare-image"],
        owner: `urn:li:person:${this.profileId}`,
        serviceRelationships: [
          {
            relationshipType: "OWNER",
            identifier: "urn:li:userGeneratedContent"
          }
        ]
      }
    };

    this.plogger.log('API Request: Register Upload', { method: 'POST', url: registerUrl, payload: registerBody });
    const registerResponse = await this.httpService.axiosRef.post(registerUrl, registerBody, this.config);
    this.plogger.log('API Response: Register Upload', { statusCode: registerResponse.status, data: registerResponse.data });

    const uploadUrl = registerResponse.data.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
    const assetUrn = registerResponse.data.value.asset;

    // PASO 2: Subir el archivo binario
    this.logger.log('Subiendo binario...');
    const fileBuffer = await this.storageService.read(filepath);
    
    this.plogger.log('API Request: Upload Binary', { method: 'POST', url: uploadUrl, sizeBytes: fileBuffer.length });
    await this.httpService.axiosRef.post(uploadUrl, fileBuffer, {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/octet-stream' // Tipo genérico para binarios
      }
    });
    this.plogger.log('API Response: Upload Binary', { statusCode: 200, message: 'Binary uploaded successfully' });

    // PASO 3: Crear el post referenciando el asset
    const postBody = {
      author: `urn:li:person:${this.profileId}`,
      lifecycleState: "PUBLISHED",
      specificContent: {
        "com.linkedin.ugc.ShareContent": {
          shareCommentary: { text: message },
          shareMediaCategory: "IMAGE",
          media: [
            {
              status: "READY",
              description: { text: "Image generated by AI" },
              media: assetUrn,
              title: { text: "Shared Image" }
            }
          ]
        }
      },
      visibility: { "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC" }
    };

    return this.sendPostRequest(postBody);
  }

  private async sendPostRequest(body: any): Promise<PublishResult> {
    const postUrl = `${this.baseUrl}/ugcPosts`;
    try {
      this.plogger.log('API Request: Create Post', { method: 'POST', url: postUrl, payload: body });
      const response = await this.httpService.axiosRef.post(postUrl, body, this.config);
      this.plogger.log('API Response: Create Post', { statusCode: response.status, data: response.data });
      this.logger.log(`Publicación exitosa en LinkedIn ID: ${response.headers['x-restli-id']}`);

      return { 
        success: true, 
        platform: this.platformName, 
        url: `https://www.linkedin.com/feed/update/${response.data.id || ''}`
      };
    } catch (error) {
      const axiosError = error as AxiosError;
      this.plogger.error('API Error: Create Post', {
        statusCode: axiosError.response?.status,
        apiError: axiosError.response?.data,
        message: axiosError.message
      });
      throw error;
    }
  }
}